<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog 2 ‚Äì Continuation of Backend Development</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 760px;
            margin: 40px auto;
            padding: 0 20px;
            line-height: 1.6;
            color: #222;
        }
        h1, h2 {
            color: #111;
        }
        pre {
            background: #f4f4f4;
            padding: 12px;
            overflow-x: auto;
            border-radius: 6px;
        }
        code {
            font-family: Consolas, monospace;
        }
    </style>
</head>
<body>

<nav>
    <div class="title"><a href="index.html" style="text-decoration:none;color:var(--text)">My Go Journeys</a></div>
    <button id="themeToggle">üåô Dark Mode</button>
</nav>

<h1>Continuation of Backend Development</h1>

<p><strong>May 31, 2025 10:19 PM</strong></p>

<p>I refactored my project by separating the <code>RootHandler</code> from <code>main.go</code>. This keeps the entry point cleaner and easier to read.</p>

<h2>Updated main.go</h2>

<pre><code>package main

import (
    rootrequesthandler "backend/root_request_handler"
    "database/sql"
    "fmt"
    "log"
    "net/http"

    _ "github.com/lib/pq"
)

var port string = ":8080"
var db *sql.DB
...
</code></pre>

<h2>RootRequestHandler</h2>

<pre><code>package rootrequesthandler

import (
    "fmt"
    "net/http"
)

type RootRequestHandler struct{}

func (rqh *RootRequestHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        rqh.handleGET(w)
    case http.MethodPost:
        rqh.handlePOST(w)
    }
}
...
</code></pre>

<h2>Exploring Handler Interfaces</h2>

<p>Using <code>mux.Handle("/", handler)</code> requires the type to implement:</p>

<pre><code>ServeHTTP(w http.ResponseWriter, r *http.Request)
</code></pre>

<p>This pattern feels similar to interface classes in OOP languages but implemented functionally in Go.</p>

<h2>Extracting DB Handler</h2>

<pre><code>package dbhandler

var db *sql.DB

func GetDB() *sql.DB {
    if db == nil {
        db = initalizeDB()
        return db
    }
    return db
}
</code></pre>

<p>I attempted a lazy singleton pattern ‚Äî not fully confident yet, but exploring!</p>

<h2>Switching to GORM</h2>

<p>Writing raw SQL was getting too time-consuming, so I introduced GORM.</p>

<pre><code>db, err = gorm.Open(postgres.Open(connStr), &gorm.Config{})
db.AutoMigrate(&userModel.User{}, &coursemodel.Course{})
</code></pre>

<p>This drastically simplifies database operations.</p>

<h2>User Handlers</h2>

<p>I added GET and POST handlers for users:</p>

<pre><code>func (uRH *UserRequestHandler) createUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    json.NewDecoder(r.Body).Decode(&req)
    user := req.createUser()
    dbhandler.GetDBPointer().Create(&user)
    json.NewEncoder(w).Encode(user)
}
</code></pre>

<h2>CreateUserRequest Adapter Pattern</h2>

<p>The request struct acts like an adapter:</p>

<pre><code>type CreateUserRequest struct {
    Name  string `json:"name"`
    Phone string `json:"phone"`
    FB_ID string `json:"fb_id"`
    Email string `json:"email"`
}

func (req *CreateUserRequest) createUser() User {
    return User{ Name: req.Name, Phone: req.Phone, FB_ID: req.FB_ID, Email: req.Email }
}
</code></pre>

<p>It converts input JSON into a DB model. Clean separation ‚Üí easier to maintain.</p>

<h2>Next Steps</h2>

<p>I want to start adopting TDD to avoid future regressions as the backend grows more complex.</p>

<p><em>June 1, 2025 1:06 AM ‚Äî Finished implementing user creation and fetching!</em></p>

<div id="blogNav" style="margin-top:40px; display:flex; justify-content:space-between;"></div>


<script>
    const toggleBtn = document.getElementById("themeToggle");
    const html = document.documentElement;

    toggleBtn.addEventListener("click", () => {
        const current = html.getAttribute("data-theme");
        const next = current === "light" ? "dark" : "light";
        html.setAttribute("data-theme", next);
        toggleBtn.textContent = next === "light" ? "üåô Dark Mode" : "‚òÄÔ∏è Light Mode";
    });
</script>

<script>
const username = "momin-mostafa";   // YOUR GitHub username
const repo = "blog-go-novice";      // YOUR repo name

async function buildNavigation() {
    const url = `https://api.github.com/repos/${username}/${repo}/contents/`;
    const res = await fetch(url);
    const files = await res.json();

    // Filter blog files: blog_1.html, blog_2.html, ...
    let blogs = files
        .filter(f => /^blog_\d+\.html$/.test(f.name))
        .map(f => f.name);

    // Sort numerically (1, 2, 3 ...)
    blogs.sort((a, b) => {
        const n1 = parseInt(a.match(/\d+/)[0]);
        const n2 = parseInt(b.match(/\d+/)[0]);
        return n1 - n2;
    });

    const current = window.location.pathname.split("/").pop();
    const index = blogs.indexOf(current);

    const blogNav = document.getElementById("blogNav");

    let html = "";

    // Previous blog
    if (index > 0) {
        html += `<button onclick="location.href='${blogs[index - 1]}'" 
                 style="padding:10px 16px; border-radius:8px; background:var(--card-bg); color:var(--text); border:none; cursor:pointer;">
                 ‚¨Ö Previous
                 </button>`;
    } else {
        html += `<div></div>`; // keeps spacing
    }

    // Next blog
    if (index < blogs.length - 1) {
        html += `<button onclick="location.href='${blogs[index + 1]}'" 
                 style="padding:10px 16px; border-radius:8px; background:var(--card-bg); color:var(--text); border:none; cursor:pointer;">
                 Next ‚ûú
                 </button>`;
    }

    blogNav.innerHTML = html;
}

buildNavigation();
</script>


</body>
</html>
